<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>Chapter 6 Preparing the data for analysis | Archaeological Science with R</title>
  <meta name="description" content="This is the book site for ‘Archaeological Science with R’." />
  <meta name="generator" content="bookdown 0.10 and GitBook 2.6.7" />

  <meta property="og:title" content="Chapter 6 Preparing the data for analysis | Archaeological Science with R" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This is the book site for ‘Archaeological Science with R’." />
  <meta name="github-repo" content="benmarwick/aswr" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Chapter 6 Preparing the data for analysis | Archaeological Science with R" />
  
  <meta name="twitter:description" content="This is the book site for ‘Archaeological Science with R’." />
  

<meta name="author" content="Ben Marwick" />


<meta name="date" content="2019-05-27" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="gettingdatain.html">
<link rel="next" href="visualisatingthedata.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<script src="libs/htmlwidgets-1.3/htmlwidgets.js"></script>
<script src="libs/plotly-binding-4.9.0/plotly.js"></script>
<script src="libs/typedarray-0.1/typedarray.min.js"></script>
<link href="libs/crosstalk-1.0.0/css/crosstalk.css" rel="stylesheet" />
<script src="libs/crosstalk-1.0.0/js/crosstalk.min.js"></script>
<link href="libs/plotly-htmlwidgets-css-1.46.1/plotly-htmlwidgets.css" rel="stylesheet" />
<script src="libs/plotly-main-1.46.1/plotly-latest.min.js"></script>


<style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

<link rel="stylesheet" href="style.css" type="text/css" />
</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li><a href="./">Archaeological Science with R</a></li>

<li class="divider"></li>
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Archaeological Science with R</a></li>
<li class="chapter" data-level="2" data-path="introduction.html"><a href="introduction.html"><i class="fa fa-check"></i><b>2</b> Introduction</a><ul>
<li class="chapter" data-level="2.1" data-path="introduction.html"><a href="introduction.html#overview"><i class="fa fa-check"></i><b>2.1</b> Overview</a></li>
<li class="chapter" data-level="2.2" data-path="introduction.html"><a href="introduction.html#why-do-archaeologists-need-to-learn-to-code"><i class="fa fa-check"></i><b>2.2</b> Why do archaeologists need to learn to code?</a></li>
<li class="chapter" data-level="2.3" data-path="introduction.html"><a href="introduction.html#why-r"><i class="fa fa-check"></i><b>2.3</b> Why R?</a></li>
<li class="chapter" data-level="2.4" data-path="introduction.html"><a href="introduction.html#who-should-read-this-book"><i class="fa fa-check"></i><b>2.4</b> Who should read this book</a></li>
<li class="chapter" data-level="2.5" data-path="introduction.html"><a href="introduction.html#prerequisites"><i class="fa fa-check"></i><b>2.5</b> Prerequisites</a><ul>
<li class="chapter" data-level="2.5.1" data-path="introduction.html"><a href="introduction.html#r"><i class="fa fa-check"></i><b>2.5.1</b> R</a></li>
<li class="chapter" data-level="2.5.2" data-path="introduction.html"><a href="introduction.html#rstudio"><i class="fa fa-check"></i><b>2.5.2</b> RStudio</a></li>
</ul></li>
<li class="chapter" data-level="2.6" data-path="introduction.html"><a href="introduction.html#key-terms-to-understand-dont-skip-this-bit"><i class="fa fa-check"></i><b>2.6</b> Key terms to understand (don’t skip this bit!)</a><ul>
<li class="chapter" data-level="2.6.1" data-path="introduction.html"><a href="introduction.html#packages"><i class="fa fa-check"></i><b>2.6.1</b> Packages</a></li>
</ul></li>
<li class="chapter" data-level="2.7" data-path="introduction.html"><a href="introduction.html#getting-help"><i class="fa fa-check"></i><b>2.7</b> Getting help</a><ul>
<li class="chapter" data-level="2.7.1" data-path="introduction.html"><a href="introduction.html#draft-toc"><i class="fa fa-check"></i><b>2.7.1</b> Draft TOC</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html"><i class="fa fa-check"></i><b>3</b> Writing reproducible research</a><ul>
<li class="chapter" data-level="3.1" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#overview-1"><i class="fa fa-check"></i><b>3.1</b> Overview</a></li>
<li class="chapter" data-level="3.2" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#what-does-it-mean-to-do-reproducible-research"><i class="fa fa-check"></i><b>3.2</b> What does it mean to do reproducible research?</a></li>
<li class="chapter" data-level="3.3" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#literate-programming"><i class="fa fa-check"></i><b>3.3</b> Literate programming</a><ul>
<li class="chapter" data-level="3.3.1" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#document-metadata-citations-and-the-bibliography"><i class="fa fa-check"></i><b>3.3.1</b> Document metadata, citations and the bibliography</a></li>
<li class="chapter" data-level="3.3.2" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#narrative-text-structuring-the-document-and-special-characters-in-the-text"><i class="fa fa-check"></i><b>3.3.2</b> Narrative text, structuring the document and special characters in the text</a></li>
<li class="chapter" data-level="3.3.3" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#code-blocks"><i class="fa fa-check"></i><b>3.3.3</b> Code blocks</a></li>
<li class="chapter" data-level="3.3.4" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#cross-referencing-and-captioning-figures"><i class="fa fa-check"></i><b>3.3.4</b> Cross-referencing and captioning figures</a></li>
<li class="chapter" data-level="3.3.5" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#cross-referencing-captioning-tables"><i class="fa fa-check"></i><b>3.3.5</b> Cross-referencing captioning tables</a></li>
<li class="chapter" data-level="3.3.6" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#using-inline-r-code-to-put-results-in-the-text"><i class="fa fa-check"></i><b>3.3.6</b> Using inline R code to put results in the text</a></li>
<li class="chapter" data-level="3.3.7" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#rendering-the-r-markdown-into-an-output-file"><i class="fa fa-check"></i><b>3.3.7</b> Rendering the R Markdown into an output file</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="writing-reproducible-research.html"><a href="writing-reproducible-research.html#summary"><i class="fa fa-check"></i><b>3.4</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="dataorganisation.html"><a href="dataorganisation.html"><i class="fa fa-check"></i><b>4</b> Collecting &amp; organising data to analyse with R</a><ul>
<li class="chapter" data-level="4.1" data-path="dataorganisation.html"><a href="dataorganisation.html#overview-2"><i class="fa fa-check"></i><b>4.1</b> Overview</a></li>
<li class="chapter" data-level="4.2" data-path="dataorganisation.html"><a href="dataorganisation.html#file-organisation"><i class="fa fa-check"></i><b>4.2</b> File organisation</a><ul>
<li class="chapter" data-level="4.2.1" data-path="dataorganisation.html"><a href="dataorganisation.html#guidelines-for-organising-your-files-for-improved-reproducibility"><i class="fa fa-check"></i><b>4.2.1</b> Guidelines for organising your files for improved reproducibility</a></li>
<li class="chapter" data-level="4.2.2" data-path="dataorganisation.html"><a href="dataorganisation.html#guidelines-for-naming-your-files-to-improve-reproducibility"><i class="fa fa-check"></i><b>4.2.2</b> Guidelines for naming your files to improve reproducibility</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="dataorganisation.html"><a href="dataorganisation.html#spreadsheets-organisation"><i class="fa fa-check"></i><b>4.3</b> Spreadsheets organisation</a></li>
<li class="chapter" data-level="4.4" data-path="dataorganisation.html"><a href="dataorganisation.html#cell-organisation"><i class="fa fa-check"></i><b>4.4</b> Cell organisation</a></li>
<li class="chapter" data-level="4.5" data-path="dataorganisation.html"><a href="dataorganisation.html#summary-1"><i class="fa fa-check"></i><b>4.5</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="gettingdatain.html"><a href="gettingdatain.html"><i class="fa fa-check"></i><b>5</b> Getting data into R</a><ul>
<li class="chapter" data-level="5.1" data-path="gettingdatain.html"><a href="gettingdatain.html#overview-3"><i class="fa fa-check"></i><b>5.1</b> Overview</a></li>
<li class="chapter" data-level="5.2" data-path="gettingdatain.html"><a href="gettingdatain.html#getting-data-from-spreadsheets"><i class="fa fa-check"></i><b>5.2</b> Getting data from spreadsheets</a><ul>
<li class="chapter" data-level="5.2.1" data-path="gettingdatain.html"><a href="gettingdatain.html#one-spreadsheet-file-one-or-more-sheets"><i class="fa fa-check"></i><b>5.2.1</b> One spreadsheet file, one or more sheets</a></li>
<li class="chapter" data-level="5.2.2" data-path="gettingdatain.html"><a href="gettingdatain.html#mulitiple-spreadsheet-files"><i class="fa fa-check"></i><b>5.2.2</b> Mulitiple spreadsheet files</a></li>
<li class="chapter" data-level="5.2.3" data-path="gettingdatain.html"><a href="gettingdatain.html#importing-messy-spreadsheets-or-when-is-it-ok-to-manually-edit-the-data"><i class="fa fa-check"></i><b>5.2.3</b> Importing messy spreadsheets, or when is it ok to manually edit the data?</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="gettingdatain.html"><a href="gettingdatain.html#tabular-data-from-non-spreadsheet-programs-pdfs-and-microsoft-word-documents"><i class="fa fa-check"></i><b>5.3</b> Tabular data from non-spreadsheet programs: PDFs and Microsoft Word documents</a></li>
<li class="chapter" data-level="5.4" data-path="gettingdatain.html"><a href="gettingdatain.html#getting-tabular-data-out-of-unstructured-files"><i class="fa fa-check"></i><b>5.4</b> Getting tabular data out of unstructured files</a></li>
<li class="chapter" data-level="5.5" data-path="gettingdatain.html"><a href="gettingdatain.html#summary-2"><i class="fa fa-check"></i><b>5.5</b> Summary</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="preparingthedata.html"><a href="preparingthedata.html"><i class="fa fa-check"></i><b>6</b> Preparing the data for analysis</a><ul>
<li class="chapter" data-level="6.1" data-path="preparingthedata.html"><a href="preparingthedata.html#overview-4"><i class="fa fa-check"></i><b>6.1</b> Overview</a></li>
<li class="chapter" data-level="6.2" data-path="preparingthedata.html"><a href="preparingthedata.html#navigating-data"><i class="fa fa-check"></i><b>6.2</b> Navigating data</a></li>
<li class="chapter" data-level="6.3" data-path="preparingthedata.html"><a href="preparingthedata.html#five-concepts-for-cleaning-data"><i class="fa fa-check"></i><b>6.3</b> Five concepts for cleaning data</a><ul>
<li class="chapter" data-level="6.3.1" data-path="preparingthedata.html"><a href="preparingthedata.html#fixing-names"><i class="fa fa-check"></i><b>6.3.1</b> Fixing names</a></li>
<li class="chapter" data-level="6.3.2" data-path="preparingthedata.html"><a href="preparingthedata.html#converting-column-classes"><i class="fa fa-check"></i><b>6.3.2</b> Converting column classes</a></li>
<li class="chapter" data-level="6.3.3" data-path="preparingthedata.html"><a href="preparingthedata.html#splitting-and-combining-columns"><i class="fa fa-check"></i><b>6.3.3</b> Splitting and combining columns</a></li>
</ul></li>
<li class="chapter" data-level="6.4" data-path="preparingthedata.html"><a href="preparingthedata.html#wide-and-long-data"><i class="fa fa-check"></i><b>6.4</b> Wide and long data</a></li>
<li class="chapter" data-level="6.5" data-path="preparingthedata.html"><a href="preparingthedata.html#dealing-with-missing-data"><i class="fa fa-check"></i><b>6.5</b> Dealing with missing data</a></li>
<li class="chapter" data-level="6.6" data-path="preparingthedata.html"><a href="preparingthedata.html#joining-data-together"><i class="fa fa-check"></i><b>6.6</b> Joining data together</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="visualisatingthedata.html"><a href="visualisatingthedata.html"><i class="fa fa-check"></i><b>7</b> Exploring the data with visualisations</a><ul>
<li class="chapter" data-level="7.1" data-path="visualisatingthedata.html"><a href="visualisatingthedata.html#overview-5"><i class="fa fa-check"></i><b>7.1</b> Overview</a></li>
<li class="chapter" data-level="7.2" data-path="visualisatingthedata.html"><a href="visualisatingthedata.html#empirical-research-into-effective-data-visualisation"><i class="fa fa-check"></i><b>7.2</b> Empirical research into effective data visualisation</a></li>
</ul></li>
<li class="part"><span><b>I Working with data</b></span></li>
<li class="chapter" data-level="8" data-path="artefactdata.html"><a href="artefactdata.html"><i class="fa fa-check"></i><b>8</b> Analysing artefact data</a><ul>
<li class="chapter" data-level="8.1" data-path="artefactdata.html"><a href="artefactdata.html#overview-6"><i class="fa fa-check"></i><b>8.1</b> Overview</a></li>
<li class="chapter" data-level="8.2" data-path="artefactdata.html"><a href="artefactdata.html#basic-analysis-tasks"><i class="fa fa-check"></i><b>8.2</b> Basic analysis tasks</a></li>
<li class="chapter" data-level="8.3" data-path="artefactdata.html"><a href="artefactdata.html#basic-plotting-tasks"><i class="fa fa-check"></i><b>8.3</b> Basic plotting tasks</a></li>
<li class="chapter" data-level="8.4" data-path="artefactdata.html"><a href="artefactdata.html#stone-artefacts"><i class="fa fa-check"></i><b>8.4</b> Stone artefacts</a></li>
<li class="chapter" data-level="8.5" data-path="artefactdata.html"><a href="artefactdata.html#faunal-remains"><i class="fa fa-check"></i><b>8.5</b> Faunal remains</a></li>
<li class="chapter" data-level="8.6" data-path="artefactdata.html"><a href="artefactdata.html#pottery"><i class="fa fa-check"></i><b>8.6</b> Pottery</a></li>
<li class="chapter" data-level="8.7" data-path="artefactdata.html"><a href="artefactdata.html#glass"><i class="fa fa-check"></i><b>8.7</b> Glass</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="compositional-pca-ca.html"><a href="compositional-pca-ca.html"><i class="fa fa-check"></i><b>9</b> compositional, PCA, CA</a><ul>
<li class="chapter" data-level="9.1" data-path="compositional-pca-ca.html"><a href="compositional-pca-ca.html#metal"><i class="fa fa-check"></i><b>9.1</b> Metal</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="shapes.html"><a href="shapes.html"><i class="fa fa-check"></i><b>10</b> shapes?</a></li>
<li class="part"><span><b>II Working with data</b></span></li>
<li class="chapter" data-level="11" data-path="stratigraphic.html"><a href="stratigraphic.html"><i class="fa fa-check"></i><b>11</b> Working with stratigraphic data from archaeological excavations</a><ul>
<li class="chapter" data-level="11.1" data-path="stratigraphic.html"><a href="stratigraphic.html#overview-7"><i class="fa fa-check"></i><b>11.1</b> Overview</a></li>
<li class="chapter" data-level="11.2" data-path="stratigraphic.html"><a href="stratigraphic.html#visualising-excavation-data"><i class="fa fa-check"></i><b>11.2</b> Visualising excavation data</a></li>
<li class="chapter" data-level="11.3" data-path="stratigraphic.html"><a href="stratigraphic.html#stratigraphic-analysis"><i class="fa fa-check"></i><b>11.3</b> Stratigraphic analysis</a></li>
<li class="chapter" data-level="11.4" data-path="stratigraphic.html"><a href="stratigraphic.html#particle-size-analysis"><i class="fa fa-check"></i><b>11.4</b> Particle size analysis</a></li>
</ul></li>
<li class="part"><span><b>III Working with data</b></span></li>
<li class="chapter" data-level="12" data-path="spatialdata.html"><a href="spatialdata.html"><i class="fa fa-check"></i><b>12</b> Spatial data and maps</a><ul>
<li class="chapter" data-level="12.1" data-path="spatialdata.html"><a href="spatialdata.html#overview-8"><i class="fa fa-check"></i><b>12.1</b> Overview</a></li>
<li class="chapter" data-level="12.2" data-path="spatialdata.html"><a href="spatialdata.html#making-maps"><i class="fa fa-check"></i><b>12.2</b> Making maps</a></li>
<li class="chapter" data-level="12.3" data-path="spatialdata.html"><a href="spatialdata.html#doing-spatial-analysis"><i class="fa fa-check"></i><b>12.3</b> Doing spatial analysis</a></li>
<li class="chapter" data-level="12.4" data-path="spatialdata.html"><a href="spatialdata.html#section"><i class="fa fa-check"></i><b>12.4</b> </a></li>
</ul></li>
<li class="divider"></li>
<li><a href="https://github.com/rstudio/bookdown" target="blank">Published with bookdown</a></li>

</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Archaeological Science with R</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="preparingthedata" class="section level1">
<h1><span class="header-section-number">Chapter 6</span> Preparing the data for analysis</h1>
<div id="overview-4" class="section level2">
<h2><span class="header-section-number">6.1</span> Overview</h2>
<p>It is rarely the case that data that are fresh from field work or obtained directly from an instrument are immediately ready for analysis and visualisation. Often there are minor inconistences and errors in the data that need to be cleared out of the data. Identifying and removing these contaminants is rarely taught during undergraduate or gradute training, and as a result, many researchers spend a lot of time struggling with making their data fit for analysis and visualisation. The aim of this chapter is to investigate five key concepts for cleaning data with R. This chapter will give you the tools to identify problems with your data, fix them quickly and simply, and get your data into a suitable shape for analysis and visualisation. First we will ensure that you can navigate your data easily, then we will describe five data cleaning concepts, and finally we will explore some methods for joining tables together.</p>
</div>
<div id="navigating-data" class="section level2">
<h2><span class="header-section-number">6.2</span> Navigating data</h2>
<p>The most natural container for tabular data in R is the data frame. Data frames have serveral variants with slightly different properties. For example in this book we frequently use the tibble class, a trimmed down version of a data frame, because it provides neater and more informative output when we print a tibble to the R console. But the core data frame functions remain the same. For example we can extract the first row of a tibble data frame called ‘my_df’ using the square braket subsetting method like so <code>my_df[1, ]</code>, and extract the third column like this <code>my_df[ , 3]</code>. On the left side of the comma in the middle of the square brakets we control how to subset the rows of the data frame, and on the right side we control how to subset the columns of the data frame. This method of square braket subsetting is useful for quick interactive exploration of the data during the data cleaning steps. The examples below show how to use the square brackets for a variety of different subsetting tasks:</p>
<pre><code>my_df[1]      # first column in the data frame (as a data frame)
my_df[, 1]    # first column in the data frame (as a vector)
my_df[[1]]    # also the first column in the data frame (as a vector)
my_df[1, 1]   # first element in the first column of the data frame 
                (as a vector)
my_df[1, 6]   # first element in the 6th column (as a vector)
my_df[1:3, 7] # first three elements in the 7th column (as a vector)
my_df[3, ]    # the 3rd element for all columns (as a data frame)
my_df[&quot;col1&quot;] # Result is a data.frame
my_df[, &quot;col1&quot;]     # Result is a vector
my_df[[&quot;col1&quot;]]     # Result is a vector
my_df$col1          # Result is a vector</code></pre>
<p>Because it can be confusing to predict the output class when using square brackets, we will use a different and more consistent method for subsetting during data analysis. But these methods are good for quickly inspecting your data and identifying cleaning tasks. In some cases a matrix may be a better container for your data than a data frame, or your data may be transformed into a matrix by a function you’re using. Matrices have similiar subsetting methods to data frames, so for the purpose of this chapter we will group them together. You may want to choose a matrix over a data frame for your data if your rectangular data is all one class (i.e. all character or all numeric), is relatively big (i.e. hundred to thousands or more or columns or rows), and you don’t need column names, then a matrix will probably take up less space in the memory of your computer and be faster to analyse.</p>
<p>A small number of data frames are can be efficently managed as individual objects in your R environment without confusion, but if you have a dozen or more data frames of similar sizes you will find yourself repeating code unnessearily as you repeat functions on each of the data frames. This can result in mistakes in your code and wasted time. A more efficient way to work with multiple data frames is to store them in a list. We have used lists extensively in the previous chapter as a conivenent way to store multiple data frames and operate on them. The square bracket method of subsetting also works on lists, and you’ll notice that the double square brackets we can use to extract a column from a data frame is used extensively for lists. This is due to the fact that on a technical level a data frame is a list of vectors of equal length <span class="citation">(Matloff <a href="#ref-Matloff2011art">2011</a>)</span>. Consider a simple list with three items, and the items are names a, b, and c:</p>
<pre><code>my_list[[1]]       # first item in the list (as the class of that item)
my_list[[3]]       # third item in the list (as the class of that item)
my_list[1]         # a list containing only the first item 
my_list[1:3]       # a list containing only the first three items 
my_list[c(1, 3)]   # a list containing only the first and third items 
my_list[[&#39;a&#39;]]     # first item in the list (as the class of that item)
my_list[&#39;b&#39;]       # a list containing only the second item in the list 
my_list$c          # third item in the list (as the class of that item)</code></pre>
<p>The general pattern is that double square brackets including an ‘unlist-ing’ step in extracting an item from the list, while the single square brackets preserve the list structure. For example, if you have a list of data frames, then ‘my_list[[1]]’ will return the first data frame in the list, as a data frame. However, ‘my_list[1]’ will return a list containing the first data frame. These might seem like arcane subtleties, but its worth to take care when subsetting a list to minimize frustration and ensure that the result is a class that is useful to your analysis.</p>
</div>
<div id="five-concepts-for-cleaning-data" class="section level2">
<h2><span class="header-section-number">6.3</span> Five concepts for cleaning data</h2>
<p>Now that we have our data imported into R, and we have some familiarity with how to access it, we can work on cleaning and tidying the data to make it ready for analysis and visualisation. Data cleaning can profoundly influence the results of a statistical analysis, so it is important to take care with these steps. I have divided this process into five common tasks that I routinely do when cleaning for analysis <span class="citation">(cf Jonge and Loo <a href="#ref-de2013introduction">2013</a>)</span>:</p>
<ol style="list-style-type: decimal">
<li>Fixing names: correting spelling, replacing spaces, etc.<br />
</li>
<li>Converting column classes: character to numeric, extracting numbers from strings, etc.<br />
</li>
<li>Splitting and combining columns: separating one col into two or more<br />
</li>
<li>Reshaping: from wide to long and long to wide</li>
</ol>
<div id="fixing-names" class="section level3">
<h3><span class="header-section-number">6.3.1</span> Fixing names</h3>
<p>Fixing names refers to two tasks: putting the correct column names on a data frame, and correcting misspellings of names of items with columns in the data frame. A common problem with column names on data frames is that the ones your expect are missing, and instead you have column names like X1, X2, X3… or V1, V2, V3… We encountered this problem in the previous chapter when we used the <code>extract_tables()</code> function from the tabulizer package to extract a table from a PDF. The first challenge with the output of that function is that it returns a matrix:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">class</span>(table_from_pdf[[<span class="dv">1</span>]])</code></pre>
<p>So we use <code>as_data_frame()</code> from the dplyr package to convert this into a tibble data frame (there is a <code>as.data.frame()</code> function for which no package is needed, but I find that the dplyr version has more useful defaults settings). We need to convert the matrix into a data frame so that we can have column with different classes, for example the ‘Sample’ column needs to be character class so it can hold a mix of letters and numbers, and the measurement columns need to be numeric so we can compute on them. So we can convert to a data frame, and then use <code>head()</code> to inspect the output:</p>
<pre class="sourceCode r"><code class="sourceCode r">terry_table &lt;-<span class="st"> </span><span class="kw">as_data_frame</span>(table_from_pdf[[<span class="dv">1</span>]])
<span class="kw">head</span>(terry_table)</code></pre>
<p>In the output we see that the actual column names are V1, V2, V3, etc., and the column names we want are in the first and second row. If the column names were exclisvely in the first row, we could assign the first row to the data frame column names, and then delete the first row. The pattern for this is:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(my_df) &lt;-<span class="st"> </span>my_df[ <span class="dv">1</span>, ]      <span class="co"># assign first row to the column names</span>
my_df        &lt;-<span class="st"> </span>my_df[<span class="op">-</span><span class="dv">1</span>, ]      <span class="co"># delete the first row </span></code></pre>
<p>Or for the same result in one line, we can use the <code>assign_colnames()</code> function from the docxtractr package. In the example below the <code>::</code> saves us from having to type <code>library(docxtractr)</code> to make the <code>assign_colnames()</code> function available to our R session:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># move the first row of the data frame to the column names</span>
my_df &lt;-<span class="st"> </span>docxtractr<span class="op">::</span><span class="kw">assign_colnames</span>(my_df, <span class="dv">1</span>)</code></pre>
<p>This is an ideal solution for this common problem where the column names are in the first row and we want to move them to the proper place. However, our example here is slighly more complex because the column names are spread across the first and second rows of the data frame. In this case, the general strategy is to create a character vecttor that is the result of pasting together the first and second row for each column, then proceed as above and move the first row to the column names. In the code below we take the first and second rows of the data frame (<code>terry_table[c(1:2), ]</code>), and use the <code>paste()</code> function to combine them into a a single character string for each column. The <code>collapse = &quot; &quot;</code> argument to to the <code>paste()</code> function indicates that we want to collapse the two items into one item where they are separated by a space. So that “Total P” (row 1 col 4), and “(mg/kg)” (row 2 col 4) become one item: “Total P (mg/kg)”. To automate this process across each column of the ‘terry_table’ data frame, we use the <code>map_chr()</code> function, which also converts the output to a character vector (compare to the generic <code>map()</code> which returns a list):</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># extract and combine first two rows</span>
terry_table_col_names &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">map_chr</span>(terry_table[<span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>), ], 
          <span class="op">~</span><span class="kw">paste</span>(.x, <span class="dt">collapse =</span> <span class="st">&quot; &quot;</span>))

<span class="co"># delete first two rows from the table</span>
terry_table &lt;-<span class="st"> </span>terry_table[<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">2</span>), ]

<span class="co"># view output </span>
terry_table_col_names</code></pre>
<p>The output is quite good, we have combined the first and second row of each column to get a meaningful set of column names. But a few problems remain: there is a space before the S in ‘Sample’ in the first item in the resulting character vector, the fifth item is only a space, with no text, and the sixth item does not have the correct symbols. The leading space in the first item is s nuisance and can easily be removed with the function <code>trimws()</code> which trims white space from the start and end of a character string (but not the internal spaces):</p>
<pre class="sourceCode r"><code class="sourceCode r">terry_table_col_names &lt;-<span class="st"> </span>
<span class="kw">trimws</span>(terry_table_col_names)

<span class="co"># see the result</span>
terry_table_col_names</code></pre>
<p>The empty element in the fifth item is due to the <code>extract_tables()</code> function guessing that there was a fifth column in this table. However, we saw in our earlier inspections that the fifth column contains no values, so it can safely be deleted from the table, and the fifth element of the names can also be deleted:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># delete the fifth column </span>
terry_table &lt;-<span class="st"> </span>terry_table[ , <span class="dv">-5</span>]

<span class="co"># delete the fifth element of the names vector</span>
terry_table_col_names &lt;-<span class="st"> </span>terry_table_col_names[<span class="op">-</span><span class="dv">5</span>]</code></pre>
<p>The only issue remaining now is the incorrect reading of the characters in the name of the last column. These errors are likely due to subtle differences in the encoding of numbers and letters in the PDF, and the types of encoding that R can easily handle. Encoding is a complex topic relating to the rules a computer follows when it stores human-readable characters as zeros and ones. In any case, the simplest fix is to directly update that item by replacing it with what we can see in the PDF that we got the data from:</p>
<pre class="sourceCode r"><code class="sourceCode r">terry_table_col_names[<span class="dv">5</span>] &lt;-<span class="st"> &quot;Ring Test Rating (1-6)&quot;</span> </code></pre>
<p>If we had a large table with many columns, and most of the column names had an encoding issue like this, we would want an automated method to deal with all the columns at once, rather than directly updating each element by hand as we did here. For example, we could use the <code>parse_character()</code> fucntion from the readr package to convert the encoding to something that looks sensible:</p>
<pre class="sourceCode r"><code class="sourceCode r">terry_table_col_names &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">parse_character</span>(terry_table_col_names, 
                  <span class="dt">locale =</span> <span class="kw">locale</span>(<span class="dt">encoding =</span> <span class="st">&quot;UTF-8&quot;</span>))</code></pre>
<p>The final step here is to assign the character vector of column names to the column names of the data frame:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">names</span>(terry_table) &lt;-<span class="st"> </span>terry_table_col_names

<span class="co"># inspect the result:</span>
<span class="kw">head</span>(terry_table)</code></pre>
<p>That completes the process of fixing the column names for this table, which is a typical set of operations for cleaning a data frame to prepare it for analysis. We still need to convert the column classes for some of the columns from character to numeric, but we will do that in a later section.</p>
<p>The second important task relating to fixing names is correcting data entry errors in values in a column. Suppose we have this simple table of artefact by colours, compiled by a group of undergraduate students:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># make a simple data frame</span>
artefacts_by_colour &lt;-<span class="st"> </span>
<span class="st">  </span>dplyr<span class="op">::</span><span class="kw">data_frame</span>(<span class="dt">colour =</span> <span class="kw">c</span>(<span class="st">&quot;red&quot;</span>, <span class="st">&quot; green&quot;</span>, <span class="st">&quot;greenish&quot;</span>, <span class="st">&quot;green-like&quot;</span>, <span class="st">&quot;bleu&quot;</span>, <span class="st">&quot;blue&quot;</span>, <span class="st">&quot;Red &quot;</span>),
                    <span class="dt">mass_kg =</span> <span class="kw">c</span>(<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">8</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">7</span>))
<span class="co"># have a look</span>
artefacts_by_colour</code></pre>
<p>At a quick glance at the ‘colour’ column we can see that ‘blue’ is mis-spelled as ‘bleu’, we might want to combine the variants of ‘green’, and ‘red’ appears in the last row with a capital ‘R’, but all the other colour names are in lower case. In a small table like this is a easy to browse the whole column, but in larger tables we can run <code>unique(artefacts_by_colour$colour)</code> to give a character vector of the unique values in the ‘colour’ column, or <code>table(artefacts_by_colour$colour)</code>, which returns a table showing each unique value and how many times it occurs in the column. However you discover the problems in a column, the good news is that these are very typical issues that make raw data dirty, and we can easily clean them in R. First, we will fix the case so that all the items in the ‘colour’ column are lower case:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span><span class="kw">tolower</span>(artefacts_by_colour<span class="op">$</span>colour)

<span class="co"># inspect the result</span>
artefacts_by_colour</code></pre>
<p>That has fixed the ‘red’ in the last row, and now we will fix the spelling mistake using the <code>if_else()</code> function. This function is from the dplyr package, there is also an <code>ifelse()</code> in base R, but I prefer the dplyr version because it is more strict, predictable and faster:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(dplyr)

artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">with</span>(artefacts_by_colour, 
       <span class="kw">if_else</span>(colour <span class="op">==</span><span class="st"> &quot;bleu&quot;</span>, 
              <span class="st">&quot;blue&quot;</span>, 
              colour))

<span class="co"># inspect the result</span>
artefacts_by_colour</code></pre>
<p>The <code>if_else()</code> function is very useful for data cleaning because we can use it to easily update values in a column. It works by evaluating a condition for each item in a vector, one-by-one, and retuning a new vector with values that depend on how each item is evaluated. In this case the condition is <code>colour == &quot;bleu&quot;</code>, which we can translate as ‘is the value of the column ’colour’ equivalent to “bleu”?‘. For each item in the ’colour’ column, the <code>if_else()</code> function will evaluate that condition and return either <code>TRUE</code> (the value is equalivant to “bleu”) or <code>FALSE</code> (the value is not “bleu”, but something else, like “red”, or “green”). The second argument to <code>if_else()</code> is the value to return if the condition is <code>TRUE</code>. In our example, we can translate this as ‘if the value of the column ’colour’ is “bleu”, then return the value “blue”‘. Or more plainly ’where “bleu” occurs in the ’colour’ column, replace it with “blue”‘, akin to a find-and-replace task you might do in a word processing document. The last argument to <code>if_else()</code> is the value to return if the condition is <code>FALSE</code>. In our example, this value is whatever the value of the ’colour’ column is. So when the <code>if_else()</code> gets to the last item in the ‘colour’ column, it sees the value “red”, and it evaluates the condition as ‘is “red” equivalent to “bleu”?’ and returns <code>FALSE</code>, and then skips over the second argument (what to return if <code>TRUE</code>) and looks at the third argument (what to return if <code>FALSE</code>), sees the column name ‘colour’ and returns the last value of that column, which is “red”. Effectively, it leaves the column values unchanged if the condition is <code>FALSE</code>.</p>
<p>Note the use of <code>with()</code> in the example above, it saves me from having to type the name of the data frame twice. Without <code>with()</code> I would have typed it like this, repeating the name of the data frame each time I refer to the ‘colour’ column:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span>
<span class="st">       </span><span class="kw">if_else</span>(artefacts_by_colour<span class="op">$</span>colour <span class="op">==</span><span class="st"> &quot;bleu&quot;</span>, 
              <span class="st">&quot;blue&quot;</span>, 
               artefacts_by_colour<span class="op">$</span>colour)</code></pre>
<p>We could use a pair of <code>if_else()</code> functions, one nested inside the other, to change ‘greenish’ and ‘green-like’, but instead will will use a simpler option. We can use the function <code>gsub()</code>, which stands for ‘global substituion’, and works by searching through each element in a vector for a match to a pattern that we supply, and then when it finds a match to that pattern, substitutes the element with a replacement that we supply. Below, we supply that pattern to match as &quot;green.*“, which translates as ‘the word green, followed by any character (indicated by the period), any number of times (indicated by the plus symbol)’. In this context, the period and plus symbol are metacharacters that have special meanings instead of their usual literal meanings. The pattern that we have supplied, using this metacharacters is called a ‘regular expression’. Working with regular expressions gives you access to a powerful, flexible, and efficient system for cleaning and manipulating data (see <span class="citation">Fitzgerald (<a href="#ref-fitzgerald2012introducing">2012</a>)</span> and <span class="citation">Friedl (<a href="#ref-friedl2002mastering">2002</a>)</span> for detailed introductions). Regular expressions are used for processing strings in many programming languages, and are notorius for their terse and cryptic appearance. However, learning to work with regular expressions is a worthwhile investment because they can save a lot of time when cleaning data. The code below shows how we use <code>gsub()</code> with a regular expression to replace”greenish&quot; and “green-like” with “green” in the ‘colour’ column:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">gsub</span>(<span class="st">&quot;green.*&quot;</span>, <span class="st">&quot;green&quot;</span>, artefacts_by_colour<span class="op">$</span>colour)

<span class="co"># inspect the result</span>
artefacts_by_colour</code></pre>
<p>In the above example we show the use of the period and asterix as metacharacters in a regular expression. If we wanted to be more selective, we could use another regular expression character, the ‘or’ symbol <code>|</code>, to indicate that we only want to subsitute for a specific set of matches:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">gsub</span>(<span class="st">&quot;greenish|green-like&quot;</span>, <span class="st">&quot;green&quot;</span>, artefacts_by_colour<span class="op">$</span>colour)</code></pre>
<p>We can group characters used in regular expressions into four categories according to their function: converters, quantifiers, positioners, and operators. Converters are perhaps the most confusing of these, because it is not always obvious what they do and how many of them to use. Table <a href="#tab:regex-converters"><strong>??</strong></a> demonstrates this challenge where <code>\\</code> seems to have two opposite functions. When working with <code>\\</code> to convert characters in a regular expression, a useful rule of thumb is to keep adding adding backslashes until it works as desired.</p>
<p>Quantifiers specify how many repetitions of the pattern we want to match in a string. Table <a href="#tab:regex-converters"><strong>??</strong></a> describes the commonly used quantifiers in R’s regular expressions.</p>
<p>Positioners, or anchors, indicate the position of a pattern to match within a string. Table <a href="#tab:regex-positioners"><strong>??</strong></a> summarisese some common positioners. These are especially useful for getting a match only at the start or end of a character string.</p>
<p>Operators are the core of a regular expression pattern, helping to define what to include in the pattern or exclude from it. Table <a href="#tab:regex-positioners"><strong>??</strong></a> summarises some common positioners</p>
<p>An good guide to regular expresions is <span class="citation">Fitzgerald (<a href="#ref-fitzgerald2012introducing">2012</a>)</span>, and for R in particular, the chapter on strings in <span class="citation">Wickham and Grolemund (<a href="#ref-wickham2016r">2016</a>)</span> is excellent (and is online here: <a href="http://r4ds.had.co.nz/strings.html" class="uri">http://r4ds.had.co.nz/strings.html</a>). There are also many useful websites summarising common uses of regular expressions in R, such as <a href="http://stat545.com/block022_regular-expression.html" class="uri">http://stat545.com/block022_regular-expression.html</a>, as well as sites to learn, build and test your regular expressions (e.g. <a href="http://www.regexr.com/" class="uri">http://www.regexr.com/</a>, <a href="https://regex101.com/" class="uri">https://regex101.com/</a>, and <a href="https://www.debuggex.com/" class="uri">https://www.debuggex.com/</a>). These sites are useful for learning more about regular expressions and understanding specific patterns, but it is easy to get confused with subtle differences in the way various programming languages interpret patterns on these websites. I find that there is no substitute for experimenting in my R console with trial and error on a very small example that represents the operation I want to apply to the full data set. Table <a href="#tab:regex-fns"><strong>??</strong></a> shows the R functions that I most commonly use when working with regular expressions in R.</p>
<p>Regular expressions are useful for many other data cleaning tasks besides fixing names, and we will see them pop up in other contexts. However, it can be templing to try to use regular expressions where another approach may be better suited. For example, you might try to write a complex regular expression where a series of simpler regular expressions or even <code>if_else()</code> statements might be easier to write and understand. When you get stuck with regular expressions, take a moment to reflect on simpler options, perhaps breaking the problem into smaller pieces and tackling each piece one at a time.</p>
<p>To return to our small table of artefacts, we are nearly done with fixing the problems in with the colour names. The data frame looks good when we view it in the console, but a final check with <code>table(artefacts_by_colour$colour)</code> reveals that we still have some inconsistences in some of the colour names.</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># check the data frame</span>
artefacts_by_colour

<span class="co"># final check to see if anything else needs fixing</span>
<span class="kw">table</span>(artefacts_by_colour<span class="op">$</span>colour)</code></pre>
<p>The output of <code>table()</code> shows that we still have two distinct names for ‘green’ and also for ‘red’, yet we cannot see any obvious differences in these names. To take a closer look, we must print the vector in isolation:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>colour</code></pre>
<p>Now we can see the problem - there are leading and trailing spaces that are revealed by the double quotation marks. Those single spaces mean that R sees &quot; green&quot; as distinct from “green”. An easy and fast way to remove these is with the <code>str_trim()</code> function from Hadley Wickham’s stringr package. After that we can use <code>table()</code> to confirm that the colour names are as expected:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(stringr)
artefacts_by_colour<span class="op">$</span>colour &lt;-<span class="st"> </span><span class="kw">str_trim</span>(artefacts_by_colour<span class="op">$</span>colour)

<span class="co"># check that the colour names are as expected</span>
<span class="kw">table</span>(artefacts_by_colour<span class="op">$</span>colour)</code></pre>
<p>In situations where you have a large number of columns we can use <code>map_df()</code> to automatically apply functions such as <code>str_trim()</code> to all the columns in a data frame, for example:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_df</span>(artefacts_by_colour, <span class="op">~</span><span class="kw">str_trim</span>(.x))</code></pre>
<p>However, this has the undesirable side-effect of coercing all columns into the character class, notice in the above output that the ‘mass_kg’ is now a character column. To trim the white space on only the character coloumns, andleave the numeric columns untouched, we can use <code>map_if()</code> and specify a condition that the columns must satisfy to determine if the function will be applied:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_if</span>(artefacts_by_colour, 
       is.character, 
       <span class="op">~</span><span class="kw">str_trim</span>(.x)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">as_data_frame</span>()</code></pre>
<p>The condition we apply here is <code>is.character()</code> which tests to see if each column is character class. If the column is character class, then the <code>str_trim()</code> function is applied to it. The output from <code>map_if()</code> is a list, so we need to add <code>as_data_frame()</code> to convert the list back into a data frame, ready for the next step.</p>
</div>
<div id="converting-column-classes" class="section level3">
<h3><span class="header-section-number">6.3.2</span> Converting column classes</h3>
<p>As we saw in the last example, sometimes functions convert our columns to classes that are unexpected or at least not convienent for our analysis. This is a common issue that can cause frustrations with data anlysis, so it is worth taking some time to check your column classes periodically during data clearning and analysis, and being familiar with quick and easy methods to change column classes. For the simplest case, a single column, we can use <code>as.numeric()</code> to coerce a column of numbers from character class to numeric class. Conisider the previous table of artefact colours and masses, and imagine that one more artefact has been added to the data. Notice that the mass value has been mistakenly entered as ‘2.5.’ with an extra period at the end:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour &lt;-<span class="st"> </span><span class="kw">rbind</span>(artefacts_by_colour, <span class="kw">c</span>(<span class="st">&quot;yellow&quot;</span>, <span class="st">&quot;2.5.&quot;</span>))

<span class="co"># have a look</span>
artefacts_by_colour</code></pre>
<p>When we read this table into R, this ‘mass_kg’ column is now a character column and our attempts to do numerical operations, like calculate the average, will fail. In a simple case like this, where we can see digits but the class is character, <code>as.numeric()</code> is a good choice:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>mass_kg &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(artefacts_by_colour<span class="op">$</span>mass_kg)

<span class="co"># see the result</span>
artefacts_by_colour</code></pre>
<p>The key thing to notice here is that while the ‘mass_kg’ column has been converted to a numeric (of the type ‘double’), the last item, which was ‘2.5.’ is now “NA”, which stands for ‘not available’. This is a special or ‘reserved’ word in the R language that represents a missing value. Is is important to be aware of missing values in your data because some common functions (such as <code>mean()</code>) will return only NA if there is even one missing value, unless you specifically instruct the function to remove the NA values (e.g. <code>mean(x, na.rm = TRUE)</code> will remove the NAs so that a mean can be calculated). In some cases data are genuinely missing, for example if the last item in the ‘mass_kg’ column was ‘??’, then all we know is that someone entered some data, but it’s not meaningful data about the mass of the artefact. But since we have ‘2.5.’ we can reasonably infer that the correct value is ‘2.5’. We can use a regular expresion to handle this situation, for example, here is a fairly comprehensive pattern that will extract numbers (including decimal values) from a wide variety of situations in a character vector:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(stringr)

x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;2.5.&quot;</span>, <span class="st">&quot;-100.001&quot;</span>, <span class="st">&quot;1.1kg&quot;</span>, <span class="st">&quot;p.10&quot;</span>, <span class="st">&quot;10kg&quot;</span>, <span class="st">&quot;1.0p5&quot;</span>, <span class="st">&quot;1p0.5&quot;</span>)
<span class="kw">str_extract</span>(x, <span class="st">&quot;-?</span><span class="ch">\\</span><span class="st">.?</span><span class="ch">\\</span><span class="st">d+</span><span class="ch">\\</span><span class="st">.*</span><span class="ch">\\</span><span class="st">d*&quot;</span>)</code></pre>
<p>It is often helpful to annotate a complex regular expression to show the role of each character:</p>
<pre><code>str_extract(x, &quot;-?\\.?\\d+\\.*\\d*&quot;)
#                |  |  |   |  |
#                |  |  |   |  \\d* matches any digit, zero or more times
#                |  |  | \\.* matches a literal period, zero or more times
#                |  | \\d+ matches any digit one or more times
#                | \\.? matches a literal period, zero or one time, in case 
#                |      of the decimal with no leading zero
#               -? matches a negative sign, zero or one time 
</code></pre>
<p>This pattern captures numbers in several typical mis-entered forms, including when units are accidently added, or stray characters appear at the beginning or end of the number. It does not do well with more ambiguous cases such as the last two items where there is a character in the middle of the number. Indeed, even as humans we cannot easily determine if ‘1.0p5’ is meant to be ‘1.005’ or ‘1.05’. We would need to consider the context of the data recording in detail to make a decision about how to handle values like that (e.g. Was the instrument even capable of reporting a mass to the nearest 0.005 kg? Can we round up to the nearest 0.5 kg wihout any substantial loss of data?). Such a complex regular expression as the previous example may cause more problems that it solves, and we may prefer a simpler, case-by-case approach for handling badly formed values. To solve only the problem of unwanted trailing characters, such a ‘2.5.’ and ‘10kg’, we can use a simpler regular expresion:</p>
<pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;2.5.&quot;</span>, <span class="st">&quot;-100.001&quot;</span>, <span class="st">&quot;1.1kg&quot;</span>, <span class="st">&quot;p.10&quot;</span>, <span class="st">&quot;10kg&quot;</span>, <span class="st">&quot;1.0p5&quot;</span>, <span class="st">&quot;1p0.5&quot;</span>)
<span class="kw">str_extract</span>(x, <span class="st">&quot;</span><span class="ch">\\</span><span class="st">d+</span><span class="ch">\\</span><span class="st">.*</span><span class="ch">\\</span><span class="st">d*&quot;</span>)</code></pre>
<p>Here it is with annotations:</p>
<pre><code>str_extract(x, &quot;\\d+\\.*\\d*&quot;)
#                |   |  |
#                |   |  \\d* matches any digit, zero or more times
#                |  \\.* matches a literal period, zero or more times
#               \\d+ matches any digit one or more times</code></pre>
<p>This works well for cases like ‘2.5.’ and ‘10kg’. Although it is not helpful for other types of mistakes, we might prefer to fix those with seperate regular expression functions. To return to our example data frame with ‘2.5.’ in the ‘mass_kg’ column, we can now extract a number from the commonly mis-typed values, and with <code>as.numeric()</code> we can coerce the column to numeric class, ready for analysis:</p>
<pre class="sourceCode r"><code class="sourceCode r">artefacts_by_colour<span class="op">$</span>mass_kg &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">as.numeric</span>(<span class="kw">str_extract</span>(artefacts_by_colour<span class="op">$</span>mass_kg, 
                         <span class="st">&quot;</span><span class="ch">\\</span><span class="st">d+</span><span class="ch">\\</span><span class="st">.*</span><span class="ch">\\</span><span class="st">d*&quot;</span>))

<span class="co"># inspect the output</span>
artefacts_by_colour</code></pre>
<p>In some situations, such as when you have much larger data frames, it may not be practical to attend to each mis-typed value and extract the numeric value, as we did in the example above. With a larger data set you may be more tolerant of missing values, and main task is simply to get all the columns into the most convienent class, and deal with the NA values later. The <code>type_convert()</code> function from the readr package solves this problem by automatically sampling a bunch of rows in each column and guessing what the class is, and then coercing the column to that class. Consider the ‘terry_table’ data frame that we worked on earlier in the chapter to fix the column names. Last we looked at it all the columns were character class, although columns 2-4 clearly contain numbers. We can use <code>type_convert()</code> to quickly and easily fix the column classes:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)

terry_table &lt;-<span class="st"> </span><span class="kw">type_convert</span>(terry_table)

<span class="co"># inspect the output</span>
<span class="kw">str</span>(terry_table)</code></pre>
<p>An especially nice detail about <code>type_convert()</code> is that is also automatically trims leading and trailing white spaces, solving the problem we saw above with &quot; green&quot; and “green”. The<code>type_convert()</code> function is automatically applied when you use any of the the <code>read_*()</code> functions from the readr package (e.g. <code>read_csv()</code> and <code>read_table2()</code>), so that can save some time and frustration by choosing one of those functions to import your data. Finally we have a table that is basically suitable for visualisation and analysis, so we should save it as a CSV ready for the next steps, and so we can deposit it in a repository where it can easilty be reused by others:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(terry_table, <span class="st">&quot;data/data_output/terry_table.csv&quot;</span>)</code></pre>
</div>
<div id="splitting-and-combining-columns" class="section level3">
<h3><span class="header-section-number">6.3.3</span> Splitting and combining columns</h3>
<p>If we look carefully at the first column of ‘terry_table’, we see sample identifiers that area combination of letters and number, and an dash as a separator. During analysis it is often useful to have each item in this identifier is a separate column so we can do group-wise comparisons. This is a common situation when samples are labelled with a string that combines several pieces of provenance information, such as abbreviations for site, sector, square, exacavation unit, etc. For example, if we want to compare all the artefacts from one square to another square, then it is convienient to have the square identifier in its own column. The exact combination of items in these identifiers varies from project to project, so here we will explore some flexible techniques for splitting one column into several which will be useful in a variety of situations.</p>
<p>The simplest method is one we have seen in the previous chapter, <code>separate()</code> from the tidyr package:</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(tidyr) <span class="co"># load the library</span>

terry_table_split &lt;-<span class="st"> </span>
terry_table <span class="op">%&gt;%</span><span class="st">            </span><span class="co"># start with the data frame</span>
<span class="st">  </span><span class="kw">separate</span>(Sample,         <span class="co"># the column to split</span>
           <span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>),    <span class="co"># new column names</span>
           <span class="st">&quot;-&quot;</span>,            <span class="co"># character to split at</span>
           <span class="dt">convert =</span> <span class="ot">TRUE</span>) <span class="co"># conver to numeric       </span></code></pre>
<p>The <code>separate()</code> function takes a data frame as its first argument (here passed invisibly by the pipe), and then the name of the column that we want to split up, followed by the names of the new columns that will be created by the function (here simply ‘a’ and ‘b’, but could be something like ‘site’, ‘square’, ‘unit’, etc.), then the character to split (here it is ‘-’, but we can aslo supply a regular expression), and finally <code>convert = TRUE</code> which ensures that our column of numbers has the numeric class. Among the other arguments to this function, one that I use occasaionlly is <code>remove =</code> which by default removes the input column from the output data frame.</p>
<p>[x] 1. Fixing names: correting spelling, replacing spaces, using ifelse, gsub, regex<br />
[x] 2. Types: character to numeric, extract numbers from strings
<a href="spatialdata.html#section"></a> 3. Splitting: separating one col into two or more, after the n-th item
<a href="spatialdata.html#section"></a> 4. Reshaping: wide &lt;-&gt; long</p>
<p>changing column names
regex to clean data values, remove spaces
getting data in the most useful object type (numeric, integer, character, factor, logical)
ifelse to update/correct data values</p>
<p>splitting one column into two or more
combining multiple columns into one for unique IDs
adding new columns based on calculations of other columns</p>
</div>
</div>
<div id="wide-and-long-data" class="section level2">
<h2><span class="header-section-number">6.4</span> Wide and long data</h2>
<p>Wide data - better for data entry
Long data - better for data analysis and viz</p>
<p>tidyr gather/spread</p>
</div>
<div id="dealing-with-missing-data" class="section level2">
<h2><span class="header-section-number">6.5</span> Dealing with missing data</h2>
<p>removing rows/columns with missing data
imputing missing values by mean value, adjacent value, ifelse for arbitrary values
filling in with previous values</p>
</div>
<div id="joining-data-together" class="section level2">
<h2><span class="header-section-number">6.6</span> Joining data together</h2>
<p>bind_rows, bind_cols
left_join</p>

</div>
</div>
<h3>References</h3>
<div id="refs" class="references">
<div id="ref-fitzgerald2012introducing">
<p>Fitzgerald, Michael. 2012. <em>Introducing Regular Expressions</em>. &quot;O’Reilly Media, Inc.&quot;.</p>
</div>
<div id="ref-friedl2002mastering">
<p>Friedl, Jeffrey EF. 2002. <em>Mastering Regular Expressions</em>. &quot;O’Reilly Media, Inc.&quot;.</p>
</div>
<div id="ref-de2013introduction">
<p>Jonge, Edwin de, and Mark van der Loo. 2013. “An Introduction to Data Cleaning with R.” <em>Statistics Netherlands, the Hauge</em>.</p>
</div>
<div id="ref-Matloff2011art">
<p>Matloff, Norman. 2011. <em>The Art of R Programming: A Tour of Statistical Software Design</em>. Book. No Starch Press.</p>
</div>
<div id="ref-wickham2016r">
<p>Wickham, Hadley, and Garrett Grolemund. 2016. “R for Data Science.” Sebastopol, CA: O’Reilly. http://​ r4ds.​ had.​ co.​ nz.</p>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="gettingdatain.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="visualisatingthedata.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/benmarwick/aswr/edit/master/inst/05-Cleaning-and-tidying-data-with-R.Rmd",
"text": "Edit"
},
"history": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

</body>

</html>
